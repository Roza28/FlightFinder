#include "MultiGraph.h"
#include "Exceptions.h"
#include "IntPair.h"
#include <iostream>
#include <iomanip>
#include <fstream>

#define inf 999999999
//=======================//
// Implemented Functions //
//=======================//
MultiGraph::MultiGraph()
{}

MultiGraph::MultiGraph(const std::string& filePath)
{
    // ============================= //
    // This function is implemented  //
    // Do not edit this function !   //
    // ============================= //
    // Tokens
    std::string tokens[5];
    std::ifstream mapFile(filePath.c_str());

    if(!mapFile.is_open())
    {
        std::cout << "Unable to open " << filePath << std::endl;
        return;
    }

    // Read line by line
    std::string line;
    while (std::getline(mapFile, line))
    {
        // Empty Line Skip
        if(line.empty()) continue;
        // Comment Skip
        if(line[0] == '#') continue;

        // Tokenize the line
        int i = 0;
        std::istringstream stream(line);
        while(stream >> tokens[i]) i++;

        // Single token (Meaning it is a vertex)
        if(i == 1)
        {
            InsertVertex(tokens[0]);
        }
        // Exactly 5 tokens (Meaning it is an edge)
        else if(i == 5)
        {
            // Rename vars for readablity
            const std::string& vertexFromName = tokens[0];
            const std::string& vertexToName = tokens[1];
            const std::string& edgeName = tokens[2];
            float weight0 = static_cast<float>(std::atof(tokens[3].c_str()));
            float weight1 = static_cast<float>(std::atof(tokens[4].c_str()));
            AddEdge(edgeName, vertexFromName, vertexToName,
                    weight0, weight1);
        }
        else std::cerr << "Token Size Mismatch" << std::endl;
    }
}

void MultiGraph::PrintPath(const std::vector<int>& orderedVertexEdgeIndexList,
                           float heuristicWeight,
                           bool sameLine) const
{
    // ============================= //
    // This function is implemented  //
    // Do not edit this file !       //
    // ============================= //

    // Name is too long
    const std::vector<int>& ove = orderedVertexEdgeIndexList;
    // Invalid list
    // At least three items should be available
    if(ove.size() < 3) return;

    // Check vertex and an edge
    for(size_t i = 0; i < orderedVertexEdgeIndexList.size(); i += 2)
    {
        int vertexId = ove[i];
        if(vertexId >= static_cast<int>(vertexList.size()))
        {
            // Return if there is a bad vertex id
            std::cout << "VertexId " << vertexId
                      << " not found!" << std::endl;
            return;
        }


        const GraphVertex& vertex = vertexList[vertexId];
        std::cout << vertex.name;
        if(!sameLine) std::cout << "\n";
        // Only find and print the weight if next is available
        if(i == ove.size() - 1) break;
        int nextVertexId = ove[i + 2];
        if(nextVertexId >= static_cast<int>(vertexList.size()))
        {
            // Return if there is a bad vertex id
            std::cout << "VertexId " << vertexId
                    << " not found!" << std::endl;
            return;
        }

        // Find the edge between these two vertices
        int localEdgeId = ove[i + 1];
        if(localEdgeId >= static_cast<int>(vertex.edges.size()))
        {
            // Return if there is a bad vertex id
            std::cout << "EdgeId " << localEdgeId
                      << " not found in " << vertexId << "!" << std::endl;
            return;
        }

        const GraphEdge& edge = vertex.edges[localEdgeId];

        // Combine with heuristic (linear interpolation)
        float weight = Lerp(edge.weight[0], edge.weight[1],
                            heuristicWeight);

        std::cout << "-" << std::setfill('-')
                  << std::setw(4)
                  << weight << "->";
    }
    // Print endline on the last vertex if same line is set
    if(sameLine) std::cout << "\n";
    // Reset fill value because it "sticks" to the std out
    std::cout << std::setfill(' ');
    std::cout.flush();
}

void MultiGraph::PrintEntireGraph() const
{
    // ============================= //
    // This function is implemented  //
    // Do not edit this function !   //
    // ============================= //
    for(size_t i = 0; i < vertexList.size(); i++)
    {
        const GraphVertex& v = vertexList[i];
        std::cout << v.name << "\n";
        for(size_t j = 0; j < v.edges.size(); j++)
        {
            const GraphEdge& edge = v.edges[j];

            // List the all vertex names and weight
            std::cout << "    -"
                      << std::setfill('-')
                      << std::setw(4) << edge.weight[0]
                      << "-"
                      << std::setw(4) << edge.weight[1]
                      << "-> ";
            std::cout << vertexList[edge.endVertexIndex].name;
            std::cout << " (" << edge.name << ")" << "\n";
        }
    }
    // Reset fill value because it "sticks" to the std out
    std::cout << std::setfill(' ');
    std::cout.flush();
}


//=======================//
//      MY HELPERS       //
//=======================//
int MultiGraph::search_vertex(std::string vertexName) const {
    for (int i = 0; i < vertexList.size();i++)
    {
        if (vertexName == vertexList[i].name)
            return i;
    }
    return -1;
}
int MultiGraph::search_edge(std::string edgeName,GraphVertex vertex,int IndexTo) const {
    for (int i = 0; i < vertex.edges.size();i++)
    {
        if (edgeName == (vertex.edges)[i].name && IndexTo == (vertex.edges)[i].endVertexIndex)
            return i;
    }
    return -1;
}



//=======================//
//          TODO         //
//=======================//
float MultiGraph::Lerp(float w0, float w1, float alpha)
{
    /* TODO */
    return (w0*(1 - alpha) + w1*alpha);
}

void MultiGraph::InsertVertex(const std::string& vertexName)
{
    /* TODO */
    if (search_vertex(vertexName) != -1)
        throw DuplicateVertexException(vertexName);
    
    GraphVertex newVertex;
    newVertex.name = vertexName;
    vertexList.push_back(newVertex); 
}

void MultiGraph::RemoveVertex(const std::string& vertexName)
{
    /* TODO */
    int Index = search_vertex(vertexName);
    if (Index == -1)
        throw VertexNotFoundException(vertexName);
    // I need two loops one for traversing the vertexList other for traversing vertexEdges
    for (int i = 0;i<vertexList.size();i++){
        for (int j = 0;j<vertexList[i].edges.size();j++){
            if (vertexList[i].edges[j].endVertexIndex == Index)
                RemoveEdge(vertexList[i].edges[j].name,vertexList[i].name,vertexList[Index].name);
        }
    }
    std::vector<GraphVertex>::iterator it;
    it = vertexList.begin() + Index;
    vertexList.erase(it);
}

void MultiGraph::AddEdge(const std::string& edgeName,
                         const std::string& vertexFromName,
                         const std::string& vertexToName,
                         float weight0, float weight1)
{
    /* TODO */
    int IndexFrom = search_vertex(vertexFromName);
    int IndexTo = search_vertex(vertexToName);
    int IndexEdge = search_edge(edgeName,vertexList[IndexFrom],IndexTo);
    if (IndexFrom == -1)
        throw VertexNotFoundException(vertexFromName);
    if(IndexTo == -1)
        throw VertexNotFoundException(vertexToName);
    if (IndexEdge != -1)
        throw SameNamedEdgeException(edgeName,vertexFromName,vertexToName);
    GraphEdge newEdge; // may give an error wrong position for variable declaration.
    newEdge.name = edgeName;
    newEdge.weight[0] = weight0; newEdge.weight[1] = weight1;
    newEdge.endVertexIndex = IndexTo;
    vertexList[IndexFrom].edges.push_back(newEdge);
}

void MultiGraph::RemoveEdge(const std::string& edgeName,
                            const std::string& vertexFromName,
                            const std::string& vertexToName)
{
    /* TODO */
    int IndexFrom = search_vertex(vertexFromName);
    int IndexTo = search_vertex(vertexToName);
    int IndexEdge = search_edge(edgeName,vertexList[IndexFrom],IndexTo);
    if (IndexFrom == -1)
        throw VertexNotFoundException(vertexFromName);
    if(IndexTo == -1)
        throw VertexNotFoundException(vertexToName);
    if(IndexEdge == -1)
        throw EdgeNotFoundException(vertexFromName,edgeName);
    std::vector<GraphEdge>::iterator it;
    it = vertexList[IndexFrom].edges.begin() + IndexEdge;
    vertexList[IndexFrom].edges.erase(it);
}

bool MultiGraph::HeuristicShortestPath(std::vector<int>& orderedVertexEdgeIndexList,
                                       const std::string& vertexNameFrom,
                                       const std::string& vertexNameTo,
                                       float heuristicWeight) const
{
    /* TODO */
    MinPairHeap<float,int> pq;
    std::vector<float> distance(vertexList.size(),inf);
    Pair<int, int> path_constructor; //key is vertexIndex, value is edgeIndex
    std::vector<Pair<int, int>> previous(vertexList.size());
    
    // initialize previous vector
    for (int i = 0; i < vertexList.size();i++){
        previous[i].key = -1;
        previous[i].value = -1;
    }
    
    int IndexFrom = search_vertex(vertexNameFrom);
    int IndexTo = search_vertex(vertexNameTo);
    
    if (IndexFrom == -1)
        throw VertexNotFoundException(vertexNameFrom);
    if(IndexTo == -1)
        throw VertexNotFoundException(vertexNameTo);
    
    distance[IndexFrom] = 0.0;
    
    //add all vertices to pq
    for (int i = 0; i < vertexList.size();i++){
        Pair<float,int> pair;
        pair.key = distance[i]; //key is distance
        pair.value = i; //value is index of vertices
        pq.push(pair);
    }
    
    while(!pq.empty()){
        int v = pq.top().value;
        pq.pop();
        for (int i = 0; i < vertexList[v].edges.size();i++){
            int adj_vertex = vertexList[v].edges[i].endVertexIndex; 
            float weight = Lerp(vertexList[v].edges[i].weight[0],vertexList[v].edges[i].weight[1],heuristicWeight);
            float new_distance = distance[v] + weight;
            if (new_distance < distance[adj_vertex]){
                distance[adj_vertex] = new_distance;
                
                //change previous
                previous[adj_vertex].key = v; //previous vertex
                previous[adj_vertex].value = i; //edge that coming-in
                
                //decrease priority
                MinPairHeap<float,int> tmp;
                while (!pq.empty()){
                    Pair<float,int> pair = pq.top();
                    if (pair.value == adj_vertex)
                        pair.key = new_distance;
                    tmp.push(pair);
                    pq.pop();
                }
                while(!tmp.empty()){
                    Pair<float,int> pair = tmp.top();
                    pq.push(pair);
                    tmp.pop();
                }        
            }
        }
    }
    
    // if shortest path does not exist return false
    if (distance[IndexTo] == inf)
        return false;
    // Now construct the path
    std::vector<int> tmp;
    std::vector<int>::iterator begin;
    path_constructor = previous[IndexTo];
    while (path_constructor.key != -1){
        begin = tmp.begin();
        tmp.insert(begin,path_constructor.value);
        begin = tmp.begin();
        tmp.insert(begin,path_constructor.key);
        path_constructor = previous[path_constructor.key];
    }
    tmp.push_back(IndexTo);
    orderedVertexEdgeIndexList = tmp;
    
    return true;
}

bool MultiGraph::FilteredShortestPath(std::vector<int>& orderedVertexEdgeIndexList,
                                      const std::string& vertexNameFrom,
                                      const std::string& vertexNameTo,
                                      float heuristicWeight,
                                      const std::vector<std::string>& edgeNames) const
{
    /* TODO */
    MinPairHeap<float,int> pq;
    std::vector<float> distance(vertexList.size(),inf);
    Pair<int, int> path_constructor; //key is vertexIndex, value is edgeIndex
    std::vector<Pair<int, int>> previous(vertexList.size());
    
    // initialize previous vector
    for (int i = 0; i < vertexList.size();i++){
        previous[i].key = -1;
        previous[i].value = -1;
    }
    
    int IndexFrom = search_vertex(vertexNameFrom);
    int IndexTo = search_vertex(vertexNameTo);
    
    if (IndexFrom == -1)
        throw VertexNotFoundException(vertexNameFrom);
    if(IndexTo == -1)
        throw VertexNotFoundException(vertexNameTo);
    
    distance[IndexFrom] = 0.0;
    
    //add all vertices to pq
    for (int i = 0; i < vertexList.size();i++){
        Pair<float,int> pair;
        pair.key = distance[i]; //key is distance
        pair.value = i; //value is index of vertices
        pq.push(pair);
    }
    
    while(!pq.empty()){
        int v = pq.top().value;
        pq.pop();
        for (int i = 0; i < vertexList[v].edges.size();i++){
            
            //filter
            bool filter = false;
            for (int j = 0; j < edgeNames.size(); j++){
                if (vertexList[v].edges[i].name == edgeNames[j])
                    filter = true;
            }
            if (filter)
                continue;
                
            int adj_vertex = vertexList[v].edges[i].endVertexIndex; 
            float weight = Lerp(vertexList[v].edges[i].weight[0],vertexList[v].edges[i].weight[1],heuristicWeight);
            float new_distance = distance[v] + weight;
            if (new_distance < distance[adj_vertex]){
                distance[adj_vertex] = new_distance;
                
                //change previous
                previous[adj_vertex].key = v; //previous vertex
                previous[adj_vertex].value = i; //edge that coming-in
                
                //decrease priority
                MinPairHeap<float,int> tmp;
                while (!pq.empty()){
                    Pair<float,int> pair = pq.top();
                    if (pair.value == adj_vertex)
                        pair.key = new_distance;
                    tmp.push(pair);
                    pq.pop();
                }
                while(!tmp.empty()){
                    Pair<float,int> pair = tmp.top();
                    pq.push(pair);
                    tmp.pop();
                }        
            }
        }
    }
    
    // if shortest path does not exist return false
    if (distance[IndexTo] == inf)
        return false;
    // Now construct the path
    std::vector<int> tmp;
    std::vector<int>::iterator begin;
    path_constructor = previous[IndexTo];
    while (path_constructor.key != -1){
        begin = tmp.begin();
        tmp.insert(begin,path_constructor.value);
        begin = tmp.begin();
        tmp.insert(begin,path_constructor.key);
        path_constructor = previous[path_constructor.key];
    }
    tmp.push_back(IndexTo);
    orderedVertexEdgeIndexList = tmp;
    
    return true;

}

int MultiGraph::BiDirectionalEdgeCount() const
{
    /* TODO */
    int BiDirectionalEdgeCount = 0;
    for (int i = 0;i<vertexList.size();i++){
        for (int j = 0;j<vertexList[i].edges.size();j++){
            std::string edgeName = vertexList[i].edges[j].name;
            int IndexTo = vertexList[i].edges[j].endVertexIndex;
            if (search_edge(edgeName,vertexList[IndexTo],i) != -1)
                BiDirectionalEdgeCount++;
        }
    }
    return (BiDirectionalEdgeCount/2);
}

int MultiGraph::MaxDepthViaEdgeName(const std::string& vertexName,
                                    const std::string& edgeName) const
{
    /* TODO */
    int max = 0;
    MinPairHeap<int,int> pq;
    std::vector<int> distance(vertexList.size(),-1);
    std::vector<bool> visited(vertexList.size(),false);
    int index = search_vertex(vertexName);
    Pair<int,int> pair;
    distance[index] = 0;
    visited[index] = true;
    pair.key = 0;
    pair.value = index;
    pq.push(pair);
    while (!pq.empty()){
        int v = pq.top().value;
        pq.pop();
        for (int i = 0; i < vertexList[v].edges.size();i++){
            if (vertexList[v].edges[i].name == edgeName && !visited[vertexList[v].edges[i].endVertexIndex]){
                distance[vertexList[v].edges[i].endVertexIndex] = distance[v] + 1;
                pair.key = distance[vertexList[v].edges[i].endVertexIndex];
                pair.value = vertexList[v].edges[i].endVertexIndex;
                pq.push(pair);
                visited[vertexList[v].edges[i].endVertexIndex] = true;
            }
            
        }
    }
    for (int i = 0; i < distance.size(); i++){
        if (distance[i] > max)
            max = distance[i];
    }
    return max;


}
// CENGFLİGHT HELPER DEFINITIONS
float MultiGraph::get_weight_w0(std::string edgeName,int from, int to) const {
    int index = search_edge(edgeName,vertexList[from],to);
    return vertexList[from].edges[index].weight[0];
}
float MultiGraph::get_weight_w1(std::string edgeName,int from, int to) const {
    int index = search_edge(edgeName,vertexList[from],to);
    return vertexList[from].edges[index].weight[1];
}

    